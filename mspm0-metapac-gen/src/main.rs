use std::{
    collections::BTreeMap,
    fmt::Write as _,
    fs::{self, File},
    io::Write as _,
    path::{Path, PathBuf},
    process::Command,
};

use anyhow::Context;
use mspm0_data_types::{Chip, Package};
use quote::quote;

mod interrupt;
mod krate;
mod linker;
mod metadata;
mod peripheral;
mod registers;

const AUTOGENERATED_TEXT: &str =
    "// This file is autogenerated by mspm0-metapac-gen: do not edit by hand.";

fn main() -> anyhow::Result<()> {
    let mut chips = BTreeMap::new();
    let out_dir = PathBuf::from("build/mspm0-metapac");
    fs::create_dir_all(&out_dir)?;

    for f in glob::glob("build/data/*")? {
        let f = f.unwrap();

        if f.file_name()
            .unwrap()
            .to_string_lossy()
            .starts_with("ignore.")
        {
            continue;
        }

        let name = f
            .file_name()
            .unwrap()
            .to_string_lossy()
            .replace(".json", "")
            .to_lowercase();

        let chip: Chip = serde_json::from_str(&fs::read_to_string(&f).unwrap())
            .context(format!("Error reading chip: {}", name))?;
        chips.insert(name, chip);
    }

    // Must generate registers before the PAC to ensure that rustfmt can resolve imports.
    registers::generate(&out_dir)?;

    let mut metadata_dedup = BTreeMap::new();

    for (name, chip) in &mut chips {
        for package in chip.packages.iter() {
            let name = format!("{name}{}", package.package.to_lowercase());

            generate_chip_pac(&name, chip, &out_dir);
            generate_chip_metadata(&name, chip, package, &out_dir, &mut metadata_dedup);

            linker::generate_device_x(&name, chip, &out_dir)?;
            linker::generate_memory_x(&name, chip, &out_dir)?;
        }
    }

    generate_all_chips(&out_dir, chips.values())?;

    krate::generate(&out_dir, &chips)?;

    Ok(())
}

fn generate_chip_pac(name: &str, chip: &Chip, out_dir: &Path) {
    let chips = out_dir.join("src/chips");
    fs::create_dir_all(&chips).unwrap();

    let chip_dir = chips.join(name);
    fs::create_dir_all(&chip_dir).unwrap();

    let path = chip_dir.join("pac.rs");
    let mut file = File::create(&path).unwrap();

    writeln!(&mut file, "{AUTOGENERATED_TEXT}").unwrap();
    writeln!(&mut file, "{}", interrupt::generate(chip)).unwrap();
    writeln!(&mut file, "{}", peripheral::generate(chip)).unwrap();

    drop(file);

    rustfmt(path);
}

fn generate_chip_metadata(
    name: &str,
    chip: &Chip,
    package: &Package,
    out_dir: &Path,
    metadata_dedup: &mut BTreeMap<String, String>,
) {
    let chips_dir = out_dir.join("src/chips");
    let dir = chips_dir.join(name);
    fs::create_dir_all(&dir).unwrap();

    let path = dir.join("metadata.rs");
    let mut file = File::create(&path).unwrap();

    let mut data = String::new();
    write!(
        &mut data,
        "
        pub(crate) static PERIPHERALS: &[Peripheral] = {};
        pub(crate) static INTERRUPTS: &[Interrupt] = {};
        pub(crate) static INTERRUPT_GROUPS: &[InterruptGroup] = {};
        pub(crate) static DMA_CHANNELS: &[DmaChannel] = {};
        pub(crate) static PINS: &[Pin] = {};
        ",
        metadata::peripherals(chip, package),
        metadata::interrupts(chip),
        metadata::interrupt_groups(chip),
        metadata::dma_channels(chip),
        metadata::pins(chip, package),
    )
    .unwrap();

    let n = metadata_dedup.len();
    let deduped_file = metadata_dedup.entry(data.clone()).or_insert_with(|| {
        let file = format!("metadata_{:04}.rs", n);
        let path = chips_dir.join(&file);

        fs::write(&path, data).unwrap();
        rustfmt(path);

        file
    });

    let family = &chip.family;

    write!(
        &mut file,
        "
        {AUTOGENERATED_TEXT}

        include!(\"../{deduped_file}\");
        pub static METADATA: Metadata = Metadata {{
            name: \"{name}\",
            family: \"{family}\",
            peripherals: PERIPHERALS,
            pins: PINS,
            interrupts: INTERRUPTS,
            interrupt_groups: INTERRUPT_GROUPS,
            dma_channels: DMA_CHANNELS,
        }};
        ",
    )
    .unwrap();

    drop(file);

    rustfmt(path);
}

fn generate_all_chips<'a>(
    out_dir: &Path,
    chips: impl Iterator<Item = &'a Chip>,
) -> anyhow::Result<()> {
    let mut list = Vec::new();

    for chip in chips {
        for package in chip.packages.iter() {
            list.push(&package.chip);
        }
    }

    let list = quote! {
        pub const ALL_CHIPS: &[&str] = &[
            #(#list),*
        ];
    };

    let all_chips = out_dir.join("src/all_chips.rs");
    fs::write(&all_chips, list.to_string())?;
    rustfmt(all_chips);

    Ok(())
}

fn rustfmt<P: AsRef<Path>>(path: P) {
    Command::new("rustfmt")
        .arg(path.as_ref())
        .spawn()
        .unwrap()
        .wait()
        .unwrap();
}
